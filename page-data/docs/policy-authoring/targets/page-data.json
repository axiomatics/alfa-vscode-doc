{"componentChunkName":"component---node-modules-smooth-doc-src-templates-doc-js","path":"/docs/policy-authoring/targets/","result":{"data":{"mdx":{"fields":{"pageType":"doc","title":"Targets","editLink":""},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Targets\",\n  \"section\": \"Policy Authoring\",\n  \"order\": 4\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"targets\"\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#targets\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Targets\"), mdx(\"p\", null, \"Targets in policies, policysets and rules are specified using the keyword \\\"target\\\". If the target is empty, it can be omitted.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-alfa\"\n  }, \"target clause Attributes.resourceType == \\\"document\\\"\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0and\\xA0Attributes.documentStatus\\xA0==\\xA0\\\"approved\\\"\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0and\\xA0stringRegexpMatch(\\\"aaa.*\\\",\\xA0Attributes.subjectId)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0clause\\xA0Attributes.actionId\\xA0==\\xA0\\\"read\\\"\\xA0or\\xA0Attributes.actionId\\xA0==\\xA0\\\"write\\\"\\n\")), mdx(\"p\", null, \"The structure of the target follows the structure of the XACML standard. At the top level, there are clauses which are ANDed together; that is, all clauses must be true for the target to match.\"), mdx(\"p\", null, \"Within a clause there are expressions that are ORed; that is, at least one of these expressions separated by the ORs must be true for the clause to be true.\"), mdx(\"p\", null, \"Each OR contains expressions that are ANDed together; that is, all of those expressions must be true for the OR to be true.\"), mdx(\"p\", null, \"The expressions that are ANDed consist of XACML match expressions, which are expressed in ALFA as either operators or function calls.\"), mdx(\"p\", null, \"To summarize the structure:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Target\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Clause\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"OR\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Attributes.resourceType == \\\"document\\\"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"AND\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"stringRegexpMatch(\\\"aaa.\", \"*\", \"\\\", Attributes.subjectId)\")))), mdx(\"p\", null, \"Unless there are several expressions, the \\\"and\\\" and \\\"or\\\" need not be written out; rather, ALFA will fill in the appropriate XACML elements automatically during compile time. The \\\"clause,\\\" however, always needs to be written out.\"), mdx(\"h2\", {\n    \"id\": \"the-match-expressions-in-the-target\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#the-match-expressions-in-the-target\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"The match expressions in the target\"), mdx(\"p\", null, \"The XACML 3.0 standard requires the Match element to contain an AttributeValue followed by an AttributeDesignator or AttributeSelector. ALFA makes it possible to ignore the order if the match function is commutative, or if there exists an inverse function to the match function. See the function declaration section for a detailed explanation of how this works. The standard functions are declared with inverses in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"system.alfa\"), \" so the user typically does not need to worry about the order.\"), mdx(\"p\", null, \"If the function is neither commutative nor has inverse function, then the order should be maintained in the match element, or an error will be shown by the compiler.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#targets","title":"Targets","items":[{"url":"#the-match-expressions-in-the-target","title":"The match expressions in the target"}]}]}}},"pageContext":{"id":"5de4ff8c-e039-5b57-8c57-b335ad7bb107"}},"staticQueryHashes":["1122327541","1531940020","1792546820","2140385554","4275725850"]}