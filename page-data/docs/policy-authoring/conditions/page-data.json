{"componentChunkName":"component---node-modules-smooth-doc-src-templates-doc-js","path":"/docs/policy-authoring/conditions/","result":{"data":{"mdx":{"fields":{"pageType":"doc","title":"Conditions","editLink":""},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Conditions\",\n  \"section\": \"Policy Authoring\",\n  \"order\": 5\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"conditions\"\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#conditions\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Conditions\"), mdx(\"p\", null, \"Conditions are another way to write expressions in XACML and are more expressive than targets, which are limited to matching attributes against constant values. With conditions, you can match attributes against other attributes, manipulate attribute values, perform arithmetic, and more.\"), mdx(\"p\", null, \"Conditions can appear in rules, policies or policy sets. Note that the XACML standard allows conditions only in rules, not in policies or policy sets. However, if the compiler encounters a condition in a policy or policy set, it will automatically generate a rule to contain the condition and a couple of extra policies with particular combining algorithms. This produces the same effect as if the condition had been written directly in the policy or policy set, which greatly simplifies the modeling of certain use cases since conditions are much more expressive than targets.\"), mdx(\"p\", null, \"A condition is written with the keyword \\\"condition\\\" followed by an expression that must return a Boolean value. Expressions in turn can consist of any operators of function calls.\"), mdx(\"p\", null, \"Here is an example of a simple condition:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-alfa\"\n  }, \"condition Attributes.userClearance >= Attributes.resourceClassification\\n\")), mdx(\"p\", null, \"In this case, the expression consists of only a single operator to check whether at least one value of the user clearance attribute is greater than or equal to at least one value of the resource classification attribute.\"), mdx(\"p\", null, \"XACML has a large set of functions to operate on attribute values. To call a function, use the function name that has been declared (in system.alfa typically) followed by the arguments in parenthesis. Here is an example of a condition that uses function calls:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-alfa\"\n  }, \"condition\\n\\xA0\\xA0\\xA0\\xA0allOf(function[stringRegexpMatch], \\\".*fishing.*\\\", [Attributes.clubMembership])\\n\\xA0\\xA0\\xA0\\xA0&& Attributes.age > 25\\n\")), mdx(\"p\", null, \"This example checks that all club memberships of the subject contain the word \\\"fishing\\\" and that the age of the subject is greater than 25.\"), mdx(\"p\", null, \"The function that is being called is allOf. It takes another function as an argument, which is done with the function\", \"[\", \"]\", \" syntax. The second parameter is a string and the third parameter is a bag of strings. The allOf function will apply the provided function, stringRegexpMatch, with the second argument and each value of the bag in the third argument in turn. If the stringRegexpMatch function returns true for each combination like this, then the allOf function returns true.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#conditions","title":"Conditions"}]}}},"pageContext":{"id":"8fe62eb9-0203-5efc-95c2-a29d4012c57a"}},"staticQueryHashes":["1022386572","1122327541","2140385554","3442269102","3587637372","4275725850"]}