{"componentChunkName":"component---node-modules-smooth-doc-src-templates-doc-js","path":"/docs/alfa-reference/operator-declarations/","result":{"data":{"mdx":{"fields":{"pageType":"doc","title":"Operator declarations","editLink":""},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Operator declarations\",\n  \"section\": \"AlfaÂ Reference\",\n  \"order\": 5\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"operator-declarations\"\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#operator-declarations\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Operator declarations\"), mdx(\"p\", null, \"Operators are declared with the keyword \\\"infix\\\", followed by the name and a table of the XACML functions that the operator has translated. system.alfa declares operators for the standard XACML functions, so in most cases there is no need for a user to declare operators.\"), mdx(\"p\", null, \"The following is an example for declaring the less-than operator.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-alfa\"\n  }, \"infix allowbags (<) = {\\n\\xA0\\xA0\\xA0\\xA0\\\"urn:oasis:names:tc:xacml:1.0:function:integer-less-than\\\"\\xA0:\\xA0integer\\xA0integer\\xA0->\\xA0boolean\\n\\xA0\\xA0\\xA0\\xA0\\\"urn:oasis:names:tc:xacml:1.0:function:double-less-than\\\"\\xA0:\\xA0double\\xA0double\\xA0->\\xA0boolean\\n\")), mdx(\"p\", null, \"An infix operator takes two arguments and returns one value. The data types of the inputs and the outputs are declared after the XACML functions that implement the operator. For each operator there may be multiple implementing XACML functions so that the operator can be too overloaded to handle different data types. In the example above, the less-than operator will be able to work on both integers and doubles. The compiler will automatically select the right XACML function depending on the argument data types.\"), mdx(\"p\", null, \"The name of the operator must consist of the following characters: '\", \"*\", \"', '/', '%', '+', '@', '\\\\^', '=', '\\\\<', '\", \">\", \"', '&', '\\\\$', '\", \"_\", \"', '\", \"|\", \"'. In addition the operator name may begin with the minus sign '-', but the minus sign may not appear anywhere except in the first position.\"), mdx(\"p\", null, \"There are two optional features for an operator declaration:\\xA0 inverses and bag overloading.\"), mdx(\"h2\", {\n    \"id\": \"operator-inverses\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#operator-inverses\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Operator inverses\"), mdx(\"p\", null, \"An operator may declare another operator to be its inverse. An operator inverse is another operator that has the property that by reversing the two arguments the inverse then returns the same result as the operator.\"), mdx(\"p\", null, \"For instance, in the example above, the inverse of the \\\"\\\\<\\\" operator is the \\\"\", \">\", \"\\\" operator. Inverses are needed because some constructs in XACML, like the \\\\<Match\", \">\", \" in a target, require a particular argument order. In XACML, the constant value in the match expression always comes before the attribute designator. ALFA allows the user to use operators with its arguments in any order and if the user wrote the arguments in the reverse order of the XACML language, the ALFA compiler will change the order and replace the operator with its inverse..\"), mdx(\"p\", null, \"Because of this, the user can write both \\\"Attributes.age \\\\< 40\\\" and \\\"40 \", \">\", \" Attributes.age\\\", although only the latter can be directly represented in XACML. If the user writes the former, the compiler will transparently produce the equivalent second form in the XACML output.\"), mdx(\"p\", null, \"Some functions are commutative, that is, they always give the same result even if the order of the arguments is reversed. One example is the \\\"==\\\" operator. An operator is declared commutative with the \\\"comm\\\" modifier, as in the following example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-alfa\"\n  }, \"infix allowbags comm (==) = {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\\"urn:oasis:names:tc:xacml:1.0:function:string-equal\\\" : string string -> boolean\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\\"urn:oasis:names:tc:xacml:1.0:function:boolean-equal\\\" : boolean boolean ->\\n\\xA0\\xA0\\xA0\\xA0\\xA0boolean\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"operator-bag-overloading\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#operator-bag-overloading\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Operator bag overloading\"), mdx(\"p\", null, \"XACML has two different forms of expression for writing the conditions of rules: conditions and targets. The structure of a condition is more free form, while the target requires less XML for simple matching against constant values.\"), mdx(\"p\", null, \"In XACML a match in a target will look for a match with any value in the attribute bag. For instance, if a target contains the expression '\\\"doctor\\\" == Attributes.role', then the expression will be true if any of several possible values for the role attributes is \\\"doctor\\\". Thus, if the subject has the roles \\\"doctor\\\" and \\\"employee\\\", then the expression will be true.\"), mdx(\"p\", null, \"In contrast, using the XACML string-equals function in a condition is more cumbersome. The function expects two atomic string values, so writing an equivalent expression in a condition would require using the any-of function: 'any-of(function\", \"[\", \"stringEquals\", \"]\", \", \\\"doctor\\\", Attributes.role)'.\"), mdx(\"p\", null, \"To make this more convenient for the user, ALFA can automatically translate operators in a condition to this form. To enable this translation for an operator, use the \\\"allowbags\\\" modifier in the operator declaration. The less-than operator in the example above makes use of this feature.\"), mdx(\"p\", null, \"Some operators should not do this translation\", \"-\", \"-arithmetic operators, for instance. Here is an example that declares the addition operator, which must not be overloaded to accept bags:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-alfa\"\n  }, \"infix comm (+) = {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\\"urn:oasis:names:tc:xacml:1.0:function:integer-add\\\" : integer integer -> integer\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\\"urn:oasis:names:tc:xacml:1.0:function:double-add\\\"\\xA0:\\xA0double\\xA0double\\xA0->\\xA0double\\n\\xA0\\xA0\\xA0\\xA0}\\n\")), mdx(\"h2\", {\n    \"id\": \"operator-precedence\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#operator-precedence\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Operator precedence\"), mdx(\"p\", null, \"Operator precedence is fixed in the ALFA grammar. The order is as follow, going from the operators that bind the weakest to the operators that bind the strongest.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Operators starting with '|'. These are right associative.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Operators starting with '&'. These are right associative.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Operators starting with '=', '<', '>' or '$'. These are left associative.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Operators starting with '@' or '^'. These are right associative.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Operators starting with '+' or '-'. These are left associative.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Operators starting with '\", \"*\", \"', '/' or '%'. These are left associative.\")), mdx(\"p\", null, \"Parenthesis can be used to control the evaluation order of operators. For instance, you can write \\\"(2+3) \", \"*\", \" 5\\\" to perform the addition of 2 and 3 before the multiplication by 5.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#operator-declarations","title":"Operator declarations","items":[{"url":"#operator-inverses","title":"Operator inverses"},{"url":"#operator-bag-overloading","title":"Operator bag overloading"},{"url":"#operator-precedence","title":"Operator precedence"}]}]}}},"pageContext":{"id":"298e41b8-1ff9-5f9f-a597-a17e3bce44eb"}},"staticQueryHashes":["1122327541","1401783372","1792546820","2140385554","3587637372","4275725850"]}