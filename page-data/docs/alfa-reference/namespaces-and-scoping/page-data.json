{"componentChunkName":"component---node-modules-smooth-doc-src-templates-doc-js","path":"/docs/alfa-reference/namespaces-and-scoping/","result":{"data":{"mdx":{"fields":{"pageType":"doc","title":"Namespaces and scoping","editLink":""},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Namespaces and scoping\",\n  \"section\": \"AlfaÂ Reference\",\n  \"order\": 3\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"namespaces-and-scoping\"\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#namespaces-and-scoping\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"16\",\n    version: \"1.1\",\n    viewBox: \"0 0 16 16\",\n    width: \"16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Namespaces and scoping\"), mdx(\"p\", null, \"XACML elements like policies, policysets and rules are given abstract identifiers (names) that are collected into namespaces. Different namespaces may reside in different files or within the same file. Namespaces can also be nested and their names accessed using the usual dot-notation from languages like Java and C\", \"#\", \".\"), mdx(\"p\", null, \"An ALFA file may contain any number of namespace declarations. All policies and policy sets and other declarations must always be inside a namespace.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example:\"), \"\\xA0The following code snippet defines policy p within namespace B, which in turn resides within namespace A. Comments are marked using '//' and '/\", \"*\", \"..\", \"*\", \"/' as is customary.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-alfa\"\n  }, \"namespace A {\\n\\xA0\\xA0\\xA0\\xA0//\\xA0(2)\\n\\xA0\\xA0\\xA0\\xA0namespace B {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0// (1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0policy p {...}\\n\\xA0\\xA0\\xA0\\xA0}\\n}\\n/* (3) */\\n\")), mdx(\"p\", null, \"To refer to policy P from code point (1), we need to use its name \\\"p\\\"; from code point (2). If no 'import' statement is added, we would use the qualified name \\\"B.p\\\"; and \\\"A.B.p\\\" from code point (3).\"), mdx(\"p\", null, \"Names from a namespace can be imported into another namespace to avoid having to indicate the chain of namespaces.\"), mdx(\"p\", null, \"For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-alfa\"\n  }, \"namespace A {\\n\\xA0\\xA0\\xA0\\xA0namespace B {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0policy p {...}\\n\\xA0\\xA0\\xA0\\xA0}\\n\\xA0\\xA0\\xA0\\xA0import B.p\\n\\xA0\\xA0\\xA0\\xA0/* (4) */\\n}\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\nnamespace C {\\n\\xA0\\xA0\\xA0\\xA0import A.B.*\\n\\xA0\\xA0\\xA0\\xA0/* (5) */\\n}\\n\")), mdx(\"p\", null, \"At points (4) and (5), policy p may now be referred to simply as \\\"p\\\".\"), mdx(\"p\", null, \"Namespaces are also used to construct default identifiers for policies, policy sets and rules.\"), mdx(\"p\", null, \"In XACML, a policy (set) and rule are uniquely identified using a URI. When the default mapping from qualified names to URIs is to be overridden, the syntax admits associating a URI constant to a name.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Examples:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-alfa\"\n  }, \"policy p = \\\"urn:example:policy:p\\\" {...}\\npolicyset q = \\\"urn:example:policy-set:q\\\" {...}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#namespaces-and-scoping","title":"Namespaces and scoping"}]}}},"pageContext":{"id":"a35e125a-c0fb-56e0-b291-abf43bfc2b05"}},"staticQueryHashes":["1122327541","1401783372","2140385554","3587637372","4275725850","918285632"]}